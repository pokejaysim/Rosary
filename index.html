        <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texas Hold'em Poker - Live Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .lobby {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }

        .lobby h1 {
            font-size: 4rem;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 20px rgba(243, 156, 18, 0.5)); }
            to { filter: drop-shadow(0 0 30px rgba(231, 76, 60, 0.8)); }
        }

        .lobby-actions {
            display: flex;
            gap: 20px;
            margin-bottom: 2rem;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.2rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: linear-gradient(45deg, #e74c3c, #f39c12);
            color: white;
            box-shadow: 0 5px 20px rgba(231, 76, 60, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(231, 76, 60, 0.6);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group input {
            padding: 15px 25px;
            font-size: 1.1rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            width: 300px;
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .input-group input:focus {
            outline: none;
            border-color: #f39c12;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
        }

        .game-table {
            display: none;
            position: relative;
            background: radial-gradient(ellipse at center, #2d4a2b 0%, #1a2f19 100%);
            border-radius: 200px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 0 100px rgba(0, 0, 0, 0.5);
            margin: 20px auto;
            max-width: 1000px;
            border: 10px solid #3e2723;
        }

        .community-cards {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 40px 0;
            min-height: 120px;
        }

        .card {
            width: 80px;
            height: 110px;
            border-radius: 10px;
            background: linear-gradient(135deg, #fff 0%, #f0f0f0 100%);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            animation: dealCard 0.5s ease-out;
        }

        @keyframes dealCard {
            from {
                transform: translateY(-50px) rotateY(180deg) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translateY(0) rotateY(0) scale(1);
                opacity: 1;
            }
        }

        .card.red { color: #e74c3c; }
        .card.black { color: #2c3e50; }

        .card.back {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: transparent;
        }

        .card.back::before {
            content: 'â™ ';
            position: absolute;
            font-size: 3rem;
            color: rgba(255, 255, 255, 0.1);
            transform: rotate(45deg);
        }

        .players-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 40px;
        }

        .player-slot {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            min-width: 200px;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .player-slot.active {
            border-color: #f39c12;
            box-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
        }

        .player-slot.current-player {
            background: rgba(243, 156, 18, 0.2);
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #f39c12;
        }

        .player-chips {
            font-size: 1.1rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip-icon {
            width: 20px;
            height: 20px;
            background: #f39c12;
            border-radius: 50%;
            display: inline-block;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }

        .player-cards {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            min-height: 110px;
        }

        .pot-info {
            text-align: center;
            margin: 30px 0;
            font-size: 1.8rem;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
        }

        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 12px 30px;
            font-size: 1rem;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-fold {
            background: #e74c3c;
            color: white;
        }

        .btn-call {
            background: #3498db;
            color: white;
        }

        .btn-raise {
            background: #2ecc71;
            color: white;
        }

        .btn-check {
            background: #95a5a6;
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .bet-input {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        .bet-input input {
            padding: 10px 20px;
            font-size: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            width: 150px;
        }

        .game-status {
            text-align: center;
            font-size: 1.2rem;
            margin: 20px 0;
            color: #ecf0f1;
            min-height: 30px;
        }

        .winner-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            z-index: 1000;
            animation: winnerPop 0.5s ease-out;
            backdrop-filter: blur(10px);
            border: 3px solid #f39c12;
            box-shadow: 0 0 50px rgba(243, 156, 18, 0.5);
        }

        @keyframes winnerPop {
            from {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .winner-announcement h2 {
            font-size: 3rem;
            color: #f39c12;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(243, 156, 18, 0.8);
        }

        .winner-announcement p {
            font-size: 1.5rem;
            margin-bottom: 30px;
        }

        .room-code {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 1.2rem;
            letter-spacing: 2px;
            margin: 20px 0;
            display: inline-block;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #f39c12;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .login-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }

        .login-container h1 {
            font-size: 4rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
        }

        .login-container p {
            font-size: 1.2rem;
            margin-bottom: 3rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .google-signin-btn {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 30px;
            background: white;
            color: #333;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .google-signin-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
        }

        .google-icon {
            width: 24px;
            height: 24px;
        }

        .user-info {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #f39c12;
        }

        .user-name {
            font-weight: 600;
            color: #f39c12;
        }

        .sign-out-btn {
            padding: 8px 16px;
            background: rgba(231, 76, 60, 0.8);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .sign-out-btn:hover {
            background: rgba(231, 76, 60, 1);
        }

        @media (max-width: 768px) {
            .lobby h1, .login-container h1 {
                font-size: 2.5rem;
            }
            
            .players-container {
                flex-direction: column;
                gap: 20px;
            }
            
            .game-table {
                padding: 20px;
                border-radius: 30px;
            }
            
            .card {
                width: 60px;
                height: 85px;
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="login-container" id="loginScreen">
            <h1>Texas Hold'em Poker</h1>
            <p>Sign in to start playing</p>
            <button class="google-signin-btn" onclick="signInWithGoogle()">
                <svg class="google-icon" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Sign in with Google
            </button>
        </div>

        <div class="lobby" id="lobby" style="display: none;">
            <div class="user-info" id="userInfo">
                <img class="user-avatar" id="userAvatar" src="" alt="Avatar">
                <span class="user-name" id="userName"></span>
                <button class="sign-out-btn" onclick="signOut()">Sign Out</button>
            </div>
            <h1>Texas Hold'em Poker</h1>
            <div class="lobby-actions">
                <button class="btn btn-primary" onclick="createGame()">Create Game</button>
                <button class="btn btn-secondary" onclick="showJoinGame()">Join Game</button>
            </div>
            <div id="joinGameSection" style="display: none;">
                <div class="input-group">
                    <input type="text" id="roomCode" placeholder="Enter room code" maxlength="6">
                </div>
                <button class="btn btn-primary" onclick="joinGame()">Join</button>
            </div>
        </div>

        <div class="game-table" id="gameTable" style="display: none;">
            <div class="user-info" style="position: relative; margin-bottom: 20px;">
                <img class="user-avatar" id="gameUserAvatar" src="" alt="Avatar">
                <span class="user-name" id="gameUserName"></span>
                <button class="sign-out-btn" onclick="leaveGame()">Leave Game</button>
            </div>
            <div class="room-code" id="roomCodeDisplay"></div>
            
            <div class="players-container">
                <div class="player-slot" id="player1">
                    <div class="player-name">Waiting for player...</div>
                    <div class="player-chips"></div>
                    <div class="player-cards"></div>
                </div>
                <div class="player-slot" id="player2">
                    <div class="player-name">Waiting for player...</div>
                    <div class="player-chips"></div>
                    <div class="player-cards"></div>
                </div>
            </div>

            <div class="pot-info">Pot: <span class="chip-icon"></span> <span id="potAmount">0</span></div>
            
            <div class="community-cards" id="communityCards"></div>
            
            <div class="game-status" id="gameStatus">Waiting for players...</div>
            
            <div class="action-buttons" id="actionButtons" style="display: none;">
                <button class="action-btn btn-fold" onclick="playerAction('fold')">Fold</button>
                <button class="action-btn btn-check" onclick="playerAction('check')">Check</button>
                <button class="action-btn btn-call" onclick="playerAction('call')">Call</button>
                <button class="action-btn btn-raise" onclick="showRaiseInput()">Raise</button>
            </div>
            
            <div class="bet-input" id="betInput" style="display: none;">
                <input type="number" id="raiseAmount" min="1" placeholder="Amount">
                <button class="action-btn btn-raise" onclick="playerAction('raise')">Confirm Raise</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-firestore-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-auth-compat.min.js"></script>
    
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDNnyiWr2HIHsvL69LboLoUCIzVmvfanW8",
            authDomain: "poker-7eeef.firebaseapp.com",
            projectId: "poker-7eeef",
            storageBucket: "poker-7eeef.firebasestorage.app",
            messagingSenderId: "203143203913",
            appId: "1:203143203913:web:ea195b6158c16c61280398"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        // Game state
        let currentGame = null;
        let playerId = null;
        let playerName = null;
        let playerPhotoURL = null;
        let gameListener = null;

        // Auth state observer
        auth.onAuthStateChanged((user) => {
            if (user) {
                // User is signed in
                playerId = user.uid;
                playerName = user.displayName;
                playerPhotoURL = user.photoURL;
                
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('lobby').style.display = 'flex';
                document.getElementById('userName').textContent = playerName;
                document.getElementById('userAvatar').src = playerPhotoURL;
            } else {
                // User is signed out
                document.getElementById('loginScreen').style.display = 'flex';
                document.getElementById('lobby').style.display = 'none';
                document.getElementById('gameTable').style.display = 'none';
                
                // Clean up any active game listeners
                if (gameListener) {
                    gameListener();
                    gameListener = null;
                }
            }
        });

        // Sign in with Google
        async function signInWithGoogle() {
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                await auth.signInWithPopup(provider);
            } catch (error) {
                console.error('Error signing in:', error);
                alert('Error signing in. Please try again.');
            }
        }

        // Sign out
        async function signOut() {
            try {
                await auth.signOut();
                currentGame = null;
                playerId = null;
                playerName = null;
            } catch (error) {
                console.error('Error signing out:', error);
            }
        }

        // Card deck
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const suitColors = { 'â™ ': 'black', 'â™£': 'black', 'â™¥': 'red', 'â™¦': 'red' };

        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function createDeck() {
            const deck = [];
            for (const suit of suits) {
                for (const rank of ranks) {
                    deck.push({ suit, rank });
                }
            }
            return shuffleDeck(deck);
        }

        function shuffleDeck(deck) {
            const newDeck = [...deck];
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            return newDeck;
        }

        async function createGame() {
            if (!auth.currentUser) {
                alert('Please sign in first');
                return;
            }

            const roomCode = generateRoomCode();
            
            const gameData = {
                roomCode,
                players: [{
                    id: playerId,
                    name: playerName,
                    chips: 5000,
                    cards: [],
                    bet: 0,
                    folded: false
                }],
                deck: createDeck(),
                communityCards: [],
                pot: 0,
                currentPlayer: 0,
                stage: 'waiting', // waiting, preflop, flop, turn, river, showdown
                currentBet: 0,
                playersActed: [],
                created: firebase.firestore.FieldValue.serverTimestamp()
            };

            try {
                await db.collection('games').doc(roomCode).set(gameData);
                startGameListener(roomCode);
                showGame(roomCode);
            } catch (error) {
                console.error('Error creating game:', error);
                alert('Error creating game. Please try again.');
            }
        }

        function showJoinGame() {
            document.getElementById('joinGameSection').style.display = 'block';
        }

        async function joinGame() {
            if (!auth.currentUser) {
                alert('Please sign in first');
                return;
            }
            
            const roomCode = document.getElementById('roomCode').value.trim().toUpperCase();
            
            if (!roomCode) {
                alert('Please enter a room code');
                return;
            }

            try {
                const gameRef = db.collection('games').doc(roomCode);
                const gameDoc = await gameRef.get();
                
                if (!gameDoc.exists) {
                    alert('Game not found');
                    return;
                }

                const gameData = gameDoc.data();
                
                if (gameData.players.length >= 2) {
                    alert('Game is full');
                    return;
                }

                gameData.players.push({
                    id: playerId,
                    name: playerName,
                    chips: 5000,
                    cards: [],
                    bet: 0,
                    folded: false
                });

                if (gameData.players.length === 2) {
                    gameData.stage = 'preflop';
                    gameData.currentPlayer = 0; // First player starts
                    gameData.playersActed = [];
                    gameData.currentBet = 0;
                    gameData.pot = 0;
                    dealCards(gameData);
                }

                await gameRef.update(gameData);
                startGameListener(roomCode);
                showGame(roomCode);
            } catch (error) {
                console.error('Error joining game:', error);
                alert('Error joining game. Please try again.');
            }
        }

        function dealCards(gameData) {
            // Deal 2 cards to each player
            for (let i = 0; i < gameData.players.length; i++) {
                gameData.players[i].cards = [
                    gameData.deck.pop(),
                    gameData.deck.pop()
                ];
                gameData.players[i].bet = 0;
                gameData.players[i].folded = false;
            }
            
            // Initialize for first turn
            gameData.currentPlayer = 0;
            gameData.playersActed = [];
            gameData.currentBet = 0;
        }

        function startGameListener(roomCode) {
            if (gameListener) {
                gameListener();
            }

            gameListener = db.collection('games').doc(roomCode)
                .onSnapshot((doc) => {
                    if (doc.exists) {
                        currentGame = doc.data();
                        currentGame.id = roomCode;
                        updateGameUI();
                    }
                });
        }

        function showGame(roomCode) {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('gameTable').style.display = 'block';
            document.getElementById('roomCodeDisplay').textContent = `Room: ${roomCode}`;
            document.getElementById('gameUserName').textContent = playerName;
            document.getElementById('gameUserAvatar').src = playerPhotoURL;
        }

        async function leaveGame() {
            if (gameListener) {
                gameListener();
                gameListener = null;
            }
            
            // TODO: Optionally remove player from game in Firestore
            
            currentGame = null;
            document.getElementById('gameTable').style.display = 'none';
            document.getElementById('lobby').style.display = 'flex';
            document.getElementById('joinGameSection').style.display = 'none';
            document.getElementById('roomCode').value = '';
        }

        function updateGameUI() {
            if (!currentGame) return;

            console.log('Game state:', {
                stage: currentGame.stage,
                currentPlayer: currentGame.currentPlayer,
                currentBet: currentGame.currentBet,
                pot: currentGame.pot,
                playersActed: currentGame.playersActed
            });

            // Update players
            currentGame.players.forEach((player, index) => {
                const playerSlot = document.getElementById(`player${index + 1}`);
                const isCurrentPlayer = index === currentGame.currentPlayer;
                const isMe = player.id === playerId;
                
                playerSlot.classList.toggle('current-player', isCurrentPlayer && currentGame.stage !== 'waiting');
                playerSlot.classList.toggle('active', isMe);
                playerSlot.style.opacity = player.folded ? '0.5' : '1';
                
                playerSlot.querySelector('.player-name').textContent = player.name + (isMe ? ' (You)' : '') + (player.folded ? ' (Folded)' : '');
                playerSlot.querySelector('.player-chips').innerHTML = `<span class="chip-icon"></span> ${player.chips}` + 
                    (player.bet > 0 ? ` (Bet: ${player.bet})` : '');
                
                const cardsContainer = playerSlot.querySelector('.player-cards');
                cardsContainer.innerHTML = '';
                
                if (player.cards && player.cards.length > 0) {
                    player.cards.forEach(card => {
                        const cardEl = document.createElement('div');
                        cardEl.className = `card ${isMe || currentGame.stage === 'showdown' ? suitColors[card.suit] : 'back'}`;
                        cardEl.textContent = isMe || currentGame.stage === 'showdown' ? `${card.rank}${card.suit}` : '';
                        cardsContainer.appendChild(cardEl);
                    });
                }
            });

            // Update pot
            document.getElementById('potAmount').textContent = currentGame.pot;

            // Update community cards
            const communityContainer = document.getElementById('communityCards');
            communityContainer.innerHTML = '';
            
            currentGame.communityCards.forEach(card => {
                const cardEl = document.createElement('div');
                cardEl.className = `card ${suitColors[card.suit]}`;
                cardEl.textContent = `${card.rank}${card.suit}`;
                communityContainer.appendChild(cardEl);
            });

            // Update game status
            updateGameStatus();

            // Update action buttons
            updateActionButtons();
        }

        function updateGameStatus() {
            const statusEl = document.getElementById('gameStatus');
            
            if (currentGame.stage === 'waiting') {
                statusEl.textContent = 'Waiting for another player...';
            } else if (currentGame.stage === 'showdown') {
                // Will be handled by winner announcement
            } else {
                const currentPlayer = currentGame.players[currentGame.currentPlayer];
                const isMyTurn = currentPlayer.id === playerId;
                
                // Show current stage
                const stageNames = {
                    'preflop': 'Pre-Flop',
                    'flop': 'Flop',
                    'turn': 'Turn',
                    'river': 'River'
                };
                
                const stageName = stageNames[currentGame.stage] || currentGame.stage;
                
                if (isMyTurn) {
                    statusEl.innerHTML = `<strong>${stageName}</strong> - Your turn to act`;
                } else {
                    statusEl.innerHTML = `<strong>${stageName}</strong> - Waiting for ${currentPlayer.name}...`;
                }
                
                // Show current bet if any
                if (currentGame.currentBet > 0) {
                    statusEl.innerHTML += ` (Current bet: ${currentGame.currentBet})`;
                }
            }
        }

        function updateActionButtons() {
            const actionButtons = document.getElementById('actionButtons');
            const betInput = document.getElementById('betInput');
            
            if (!currentGame || !currentGame.players) return;
            
            const currentPlayer = currentGame.players[currentGame.currentPlayer];
            const isMyTurn = currentPlayer && currentPlayer.id === playerId;
            const myPlayer = currentGame.players.find(p => p.id === playerId);
            
            console.log('Action buttons update:', {
                currentPlayerIndex: currentGame.currentPlayer,
                currentPlayerId: currentPlayer?.id,
                myPlayerId: playerId,
                isMyTurn,
                stage: currentGame.stage,
                myPlayerFolded: myPlayer?.folded
            });
            
            if (isMyTurn && currentGame.stage !== 'waiting' && currentGame.stage !== 'showdown' && !myPlayer.folded) {
                actionButtons.style.display = 'flex';
                
                // Update button states
                const checkBtn = actionButtons.querySelector('.btn-check');
                const callBtn = actionButtons.querySelector('.btn-call');
                const raiseBtn = actionButtons.querySelector('.btn-raise');
                
                const callAmount = currentGame.currentBet - myPlayer.bet;
                
                if (callAmount === 0) {
                    checkBtn.style.display = 'block';
                    callBtn.style.display = 'none';
                } else {
                    checkBtn.style.display = 'none';
                    callBtn.style.display = 'block';
                    
                    // Handle all-in situations
                    if (callAmount >= myPlayer.chips) {
                        callBtn.textContent = `All-in ${myPlayer.chips}`;
                    } else {
                        callBtn.textContent = `Call ${callAmount}`;
                    }
                }
                
                // Disable raise if player doesn't have enough chips
                if (myPlayer.chips <= callAmount) {
                    raiseBtn.disabled = true;
                } else {
                    raiseBtn.disabled = false;
                }
            } else {
                actionButtons.style.display = 'none';
                betInput.style.display = 'none';
            }
        }

        function showRaiseInput() {
            document.getElementById('betInput').style.display = 'flex';
            const myPlayer = currentGame.players.find(p => p.id === playerId);
            const callAmount = currentGame.currentBet - myPlayer.bet;
            const minRaise = Math.max(callAmount * 2, 50); // Minimum raise is double the call or 50
            const maxRaise = myPlayer.chips - callAmount;
            
            const raiseInput = document.getElementById('raiseAmount');
            raiseInput.min = minRaise;
            raiseInput.max = maxRaise;
            raiseInput.value = minRaise;
            raiseInput.placeholder = `Min: ${minRaise}, Max: ${maxRaise}`;
        }

        async function playerAction(action) {
            const myPlayerIndex = currentGame.players.findIndex(p => p.id === playerId);
            const myPlayer = currentGame.players[myPlayerIndex];
            const gameRef = db.collection('games').doc(currentGame.id);
            
            try {
                const updates = {
                    players: currentGame.players,
                    pot: currentGame.pot,
                    currentBet: currentGame.currentBet,
                    currentPlayer: currentGame.currentPlayer,
                    stage: currentGame.stage,
                    communityCards: currentGame.communityCards,
                    deck: currentGame.deck,
                    playersActed: currentGame.playersActed || []
                };

                switch (action) {
                    case 'fold':
                        myPlayer.folded = true;
                        // When folding, we still count as having acted
                        if (!updates.playersActed.includes(myPlayerIndex)) {
                            updates.playersActed.push(myPlayerIndex);
                        }
                        break;
                        
                    case 'check':
                        // No action needed for chips
                        break;
                        
                    case 'call':
                        const callAmount = currentGame.currentBet - myPlayer.bet;
                        const actualCallAmount = Math.min(callAmount, myPlayer.chips);
                        
                        myPlayer.chips -= actualCallAmount;
                        myPlayer.bet += actualCallAmount;
                        updates.pot += actualCallAmount;
                        break;
                        
                    case 'raise':
                        const raiseAmount = parseInt(document.getElementById('raiseAmount').value);
                        if (isNaN(raiseAmount) || raiseAmount <= 0) {
                            alert('Please enter a valid raise amount');
                            return;
                        }
                        
                        const callCost = currentGame.currentBet - myPlayer.bet;
                        const totalCost = callCost + raiseAmount;
                        
                        if (totalCost <= myPlayer.chips) {
                            myPlayer.chips -= totalCost;
                            myPlayer.bet = currentGame.currentBet + raiseAmount;
                            updates.pot += totalCost;
                            updates.currentBet = myPlayer.bet;
                            // When someone raises, only they have acted in this betting round
                            updates.playersActed = [myPlayerIndex];
                        } else {
                            alert('Insufficient chips for this raise');
                            return;
                        }
                        document.getElementById('betInput').style.display = 'none';
                        document.getElementById('raiseAmount').value = '';
                        break;
                }

                // Track that this player has acted (unless they raised, or already acted for fold)
                if (action !== 'raise' && action !== 'fold' && !updates.playersActed.includes(myPlayerIndex)) {
                    updates.playersActed.push(myPlayerIndex);
                }

                console.log('After action:', {
                    action,
                    playerIndex: myPlayerIndex,
                    playersActed: updates.playersActed,
                    currentBet: updates.currentBet,
                    shouldAdvance: shouldAdvanceStage(updates)
                });

                // Check if we need to advance to next stage
                if (shouldAdvanceStage(updates)) {
                    advanceStage(updates);
                } else {
                    // Move to next player
                    let nextPlayer = (updates.currentPlayer + 1) % updates.players.length;
                    
                    // Skip folded players
                    let attempts = 0;
                    while (updates.players[nextPlayer].folded && attempts < updates.players.length) {
                        nextPlayer = (nextPlayer + 1) % updates.players.length;
                        attempts++;
                    }
                    
                    // Safety check: if all players are folded except one (shouldn't happen but just in case)
                    if (attempts >= updates.players.length) {
                        advanceStage(updates);
                    } else {
                        updates.currentPlayer = nextPlayer;
                    }
                }

                await gameRef.update(updates);
            } catch (error) {
                console.error('Error performing action:', error);
                alert('Error performing action. Please try again.');
            }
        }

        function shouldAdvanceStage(gameData) {
            const activePlayers = gameData.players.filter(p => !p.folded);
            
            // If only one player left, they win
            if (activePlayers.length === 1) {
                return true;
            }
            
            // Initialize playersActed if it doesn't exist
            if (!gameData.playersActed) {
                gameData.playersActed = [];
            }
            
            // Check if all active players have matched the current bet
            const allMatched = activePlayers.every(p => p.bet === gameData.currentBet || p.chips === 0);
            
            // Count active players who need to act
            const activePlayerIndices = gameData.players
                .map((p, i) => ({ player: p, index: i }))
                .filter(({ player }) => !player.folded)
                .map(({ index }) => index);
            
            // Check if all active players have acted
            const allActivePlayersActed = activePlayerIndices.every(index => 
                gameData.playersActed.includes(index)
            );
            
            // Advance if all active players have acted and all bets are matched
            return allActivePlayersActed && allMatched;
        }

        function advanceStage(gameData) {
            // Reset bets and players acted for new betting round
            gameData.players.forEach(p => p.bet = 0);
            gameData.currentBet = 0;
            gameData.currentPlayer = 0;
            gameData.playersActed = [];
            
            const activePlayers = gameData.players.filter(p => !p.folded);
            
            // If only one player remains, they win
            if (activePlayers.length === 1) {
                gameData.stage = 'showdown';
                determineWinner(gameData);
                return;
            }
            
            switch (gameData.stage) {
                case 'preflop':
                    gameData.stage = 'flop';
                    // Deal 3 community cards
                    for (let i = 0; i < 3; i++) {
                        gameData.communityCards.push(gameData.deck.pop());
                    }
                    break;
                    
                case 'flop':
                    gameData.stage = 'turn';
                    // Deal 1 card
                    gameData.communityCards.push(gameData.deck.pop());
                    break;
                    
                case 'turn':
                    gameData.stage = 'river';
                    // Deal 1 card
                    gameData.communityCards.push(gameData.deck.pop());
                    break;
                    
                case 'river':
                    gameData.stage = 'showdown';
                    determineWinner(gameData);
                    break;
            }
        }

        function determineWinner(gameData) {
            const activePlayers = gameData.players.filter(p => !p.folded);
            
            if (activePlayers.length === 1) {
                // Winner by default
                showWinner(activePlayers[0], gameData.pot);
                resetGame(gameData);
            } else {
                // Evaluate hands
                const playerHands = activePlayers.map(player => ({
                    player,
                    hand: evaluateHand([...player.cards, ...gameData.communityCards])
                }));
                
                // Sort by hand rank
                playerHands.sort((a, b) => compareHands(b.hand, a.hand));
                
                const winner = playerHands[0].player;
                showWinner(winner, gameData.pot, playerHands[0].hand);
                
                // Give pot to winner
                winner.chips += gameData.pot;
                resetGame(gameData);
            }
        }

        function evaluateHand(cards) {
            // This is a simplified hand evaluation
            // In a real game, you'd want a more comprehensive poker hand evaluator
            const ranks = cards.map(c => getRankValue(c.rank));
            const suits = cards.map(c => c.suit);
            
            const rankCounts = {};
            ranks.forEach(rank => {
                rankCounts[rank] = (rankCounts[rank] || 0) + 1;
            });
            
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            const uniqueRanks = Object.keys(rankCounts).map(Number).sort((a, b) => b - a);
            
            // Check for flush
            const suitCounts = {};
            suits.forEach(suit => {
                suitCounts[suit] = (suitCounts[suit] || 0) + 1;
            });
            const isFlush = Object.values(suitCounts).some(count => count >= 5);
            
            // Check for straight
            const isStraight = checkStraight(uniqueRanks);
            
            // Determine hand rank
            if (isStraight && isFlush) return { rank: 8, name: 'Straight Flush' };
            if (counts[0] === 4) return { rank: 7, name: 'Four of a Kind' };
            if (counts[0] === 3 && counts[1] === 2) return { rank: 6, name: 'Full House' };
            if (isFlush) return { rank: 5, name: 'Flush' };
            if (isStraight) return { rank: 4, name: 'Straight' };
            if (counts[0] === 3) return { rank: 3, name: 'Three of a Kind' };
            if (counts[0] === 2 && counts[1] === 2) return { rank: 2, name: 'Two Pair' };
            if (counts[0] === 2) return { rank: 1, name: 'Pair' };
            
            return { rank: 0, name: 'High Card', highCard: Math.max(...ranks) };
        }

        function getRankValue(rank) {
            const values = { 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
            return values[rank] || parseInt(rank);
        }

        function checkStraight(ranks) {
            if (ranks.length < 5) return false;
            
            for (let i = 0; i <= ranks.length - 5; i++) {
                let isStraight = true;
                for (let j = 0; j < 4; j++) {
                    if (ranks[i + j] - ranks[i + j + 1] !== 1) {
                        isStraight = false;
                        break;
                    }
                }
                if (isStraight) return true;
            }
            
            // Check for A-2-3-4-5 straight
            if (ranks.includes(14) && ranks.includes(2) && ranks.includes(3) && 
                ranks.includes(4) && ranks.includes(5)) {
                return true;
            }
            
            return false;
        }

        function compareHands(a, b) {
            if (a.rank !== b.rank) return a.rank - b.rank;
            if (a.highCard && b.highCard) return a.highCard - b.highCard;
            return 0;
        }

        function showWinner(winner, pot, hand) {
            const announcement = document.createElement('div');
            announcement.className = 'winner-announcement';
            announcement.innerHTML = `
                <h2>ðŸŽ‰ Winner! ðŸŽ‰</h2>
                <p>${winner.name} wins ${pot} chips!</p>
                ${hand ? `<p>With: ${hand.name}</p>` : ''}
                <button class="btn btn-primary" onclick="closeWinnerAnnouncement()">Continue</button>
            `;
            document.body.appendChild(announcement);
        }

        function closeWinnerAnnouncement() {
            const announcement = document.querySelector('.winner-announcement');
            if (announcement) {
                announcement.remove();
            }
        }

        function resetGame(gameData) {
            // Reset for next hand
            gameData.deck = createDeck();
            gameData.communityCards = [];
            gameData.pot = 0;
            gameData.currentBet = 0;
            gameData.currentPlayer = 0;
            gameData.stage = 'preflop';
            gameData.playersActed = [];
            
            gameData.players.forEach(player => {
                player.cards = [];
                player.bet = 0;
                player.folded = false;
            });
            
            dealCards(gameData);
        }
    </script>
</body>
</html>